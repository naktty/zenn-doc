---
title: ""
emoji: "💬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# GraphQL::Batchとは
[公式のREADME](https://github.com/Shopify/graphql-batch?tab=readme-ov-file#graphqlbatch)によると...
> Provides an executor for the graphql gem which allows queries to be batched.

直訳：クエリをバッチ処理できる graphql gem 用のエクゼキュータを提供します

直訳だとよくわからなかったのですが、主にGraphQLで発生するN+1問題を解決するためのライブラリだと理解してます。


# N+1問題の例とGraphQL::Batchによる解決策
## version
下記を前提とします。

- Ruby 3.3.1
- Rails 7.0.8
- graphql 2.4.9
- graphql-batch 0.6.0

## N+1問題の具体例
前準備として下記のようなModel、Type、Query、Resolverを用意しました。

### Model
UserモデルとPhotoモデルを作成し、1対多の関連を設定します。

```ruby
# app/models/user.rb
class User < ApplicationRecord
  has_many :photos, dependent: :destroy
end

# app/models/photo.rb
class Photo < ApplicationRecord
  belongs_to :user
end
```

### Type
UserTypeとPhotoTypeを作成し、UserTypeにはposted_photosフィールドを設定して、Userが投稿したPhotoを取得できるようにします。
```ruby
# app/graphql/types/user_type.rb
module Types
  class UserType < Types::BaseObject
    field :id, ID, null: false
    field :name, String
    field :posted_photos, [Types::PhotoType], null: false

    def posted_photos
      object.photos
    end
  end
end

# app/graphql/types/photo_type.rb
module Types
  class PhotoType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :posted_by, Types::UserType, null: false

    def posted_by
      object.user
    end
  end
end

```

### Resolvers
すべてのユーザーを取得するQueryを作成します。
```ruby
# app/graphql/resolvers/all_users.rb
module Resolvers
  class AllUsers < BaseResolver
    type [Types::UserType], null: false

    def resolve
      ::User.all
    end
  end
end
```

### Query
用意したModel、Type、Resolverを利用して、GraphiQLで下記のクエリを実行すると...
```graphql
query {
  allUsers {
    id
    name
    postedPhotos {
      name
    }
  }
}
```

### Response
クエリの結果はこのようになります。
```json
{
  "data": {
    "allUsers": [
      {
        "id": "1",
        "name": "テストユーザー1",
        "postedPhotos": [
          {
            "name": "カフェでの一枚"
          },
          {
            "name": "美味しい料理"
          },
          {
            "name": "チームミーティング"
          }
        ]
      },
      {
        "id": "2",
        "name": "テストユーザー2",
        "postedPhotos": [
          {
            "name": "山の頂上"
          },
          {
            "name": "お気に入りの場所"
          },
          // 以下略
        ]
      }
    ]
  }
}
```

### 発行されるSQL
Railsのログを確認すると、下記のようなSQLが発行されており、N+1問題が発生していることがわかります。

```sql
User Load (0.9ms)  SELECT `users`.* FROM `users`
Photo Load (0.3ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 1
Photo Load (0.2ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 2
Photo Load (0.1ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 3
Photo Load (0.1ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 4
Photo Load (0.1ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 5
```

## GraphQL::Batchによる解決策

graphql-batch gem の Loaders::AssociationLoaderを利用して、N+1問題を解決します。

### GraphQL::Batchの導入
Gemfileに下記を追加して、`bundle install` を実行します。
```ruby:Gemfile
gem 'graphql-batch'
```

schemaの設定を下記のように修正します。
```diff ruby:app/graphql/****_schema.rb
class ****Schema < GraphQL::Schema
  mutation(Types::MutationType)
  query(Types::QueryType)

+ use GraphQL::Batch

  # 以下略
end
```

### AssociationLoader
GraphQL::Batchの[examplesディレクトリ](https://github.com/Shopify/graphql-batch/tree/main/examples)に、ActiveRecord用のLoaderの例が用意されています。

そのうちの一つであるAssociationLoaderを利用すると、ActiveRecordのアソシエーションを効率的にまとめて読み込むことができます。

今回は、[examplesディレクトリ](https://github.com/Shopify/graphql-batch/tree/main/examples)にある association_loader.rb の内容そのままで下記のLoaderを作成し、UserTypeのposted_photosフィールドで利用してみます。

```ruby:app/graphql/loaders/association_loader.rb
module Loaders
  class AssociationLoader < GraphQL::Batch::Loader
    def self.validate(model, association_name)
      new(model, association_name)
      nil
    end

    def initialize(model, association_name)
      super()
      @model = model
      @association_name = association_name
      validate
    end

    def load(record)
      raise TypeError, "#{@model} loader can't load association for #{record.class}" unless record.is_a?(@model)
      return Promise.resolve(read_association(record)) if association_loaded?(record)

      super
    end

    # We want to load the associations on all records, even if they have the same id
    def cache_key(record)
      record.object_id
    end

    def perform(records)
      preload_association(records)
      records.each {|record| fulfill(record, read_association(record)) }
    end

    private

      def validate
        unless @model.reflect_on_association(@association_name)
          raise ArgumentError, "No association #{@association_name} on #{@model}"
        end
      end

      def preload_association(records)
        ::ActiveRecord::Associations::Preloader.new(records: records, associations: @association_name).call
      end

      def read_association(record)
        record.public_send(@association_name)
      end

      def association_loaded?(record)
        record.association(@association_name).loaded?
      end
  end
end
```

### Type
UserTypeのposted_photosフィールドを下記のように修正します。

AssociationLoaderは、`AssociationLoader.for(model, association_name).load(object)` という形式で、指定されたモデルの指定された関連をロードできます。

```diff ruby:user_type.rb
module Types
  class UserType < Types::BaseObject
    field :id, ID, null: false
    field :name, String
    field :posted_photos, [Types::PhotoType], null: false

    def posted_photos
+     Loaders::AssociationLoader.for(User, :photos).load(object)
-     object.photos
    end
  end
end
```

### 発行されるSQL
UserTypeの変更後に下記クエリを再度GraphiQLで実行してみます。

```graphql
query {
  allUsers {
    id
    name
    postedPhotos {
      name
    }
  }
}
```

クエリ実行後にRailsのログを確認すると、下記のようなSQLが発行されており、N+1問題が解決されていることがわかります🎊

```sql
User Load (0.2ms)  SELECT `users`.* FROM `users`
Photo Load (2.6ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` IN (1, 2, 3, 4, 5)
```

N+1問題が解決されのでめでたしめでたし...という感じなのですが、ここで思ったのです。

AssociationLoaderの中身をコピペしただけで、中身をよく理解しないまま使ってしまってるなと...

ということで、仕組みを理解するため、無謀にもAssociationLoaderのコードリーディングに挑戦することにしました。

以下はその記録です。

# コードリーディング

## AssociationLoader.for
`Loaders::AssociationLoader.for(User, :photos)` を実行した場合の処理の流れを追ってみます。

上記を実行すると、AssociationLoader が継承している GraphQL::Batch::Loader 内に定義されている 下記の`for` メソッドが呼び出されます。

https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/loader.rb#L3-L14

Ruby 2.7 以降であれば、引数転送構文を利用するdef self.for(...) の部分が実行されます。

### GraphQL::Batch::Loader.loader_key_for
self.for(...)の中身を見ていきます。

https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/loader.rb#L16-L18
* `for`メソッドで渡された引数 User と :photos が、group_args として [User, :photos] にまとめられ、キーワード引数は空のハッシュ {} となります。
* また、self はこの場合 Loaders::AssociationLoader になります。
* 結果として、ローダーキーは
  [Loaders::AssociationLoader, {}, [User, :photos]]
  となり、このキーを使って同じ引数での呼び出しがあれば同じローダーを再利用する仕組みになっています。
