---
title: ""
emoji: "💬"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# GraphQL::Batchとは
[公式のREADME](https://github.com/Shopify/graphql-batch?tab=readme-ov-file#graphqlbatch)によると...
> Provides an executor for the graphql gem which allows queries to be batched.

直訳：クエリをバッチ処理できる graphql gem 用のエクゼキュータを提供します

直訳だとよくわからなかったのですが、主にGraphQLで発生するN+1問題を解決するためのライブラリだと理解してます。


# N+1問題の例とGraphQL::Batchによる解決策
## version
下記を前提とします。

- Ruby 3.3.1
- Rails 7.0.8
- graphql 2.4.9
- graphql-batch 0.6.0

## N+1問題の具体例
まずはサクッとN+1問題を引き起こす💥ために、下記のようなModel、Type、Query、Resolverを用意しました。

### Model
UserモデルとPhotoモデルを作成し、1対多の関連を設定します。

```ruby
# app/models/user.rb
class User < ApplicationRecord
  has_many :photos, dependent: :destroy
end

# app/models/photo.rb
class Photo < ApplicationRecord
  belongs_to :user
end
```

### Type
UserTypeとPhotoTypeを作成し、UserTypeにはposted_photosフィールドを設定して、Userが投稿したPhotoを取得できるようにします。
```ruby
# app/graphql/types/user_type.rb
module Types
  class UserType < Types::BaseObject
    field :id, ID, null: false
    field :name, String
    field :posted_photos, [Types::PhotoType], null: false

    def posted_photos
      object.photos
    end
  end
end

# app/graphql/types/photo_type.rb
module Types
  class PhotoType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :posted_by, Types::UserType, null: false

    def posted_by
      object.user
    end
  end
end

```

### Resolvers
すべてのユーザーを取得するQueryを作成します。
```ruby
# app/graphql/resolvers/all_users.rb
module Resolvers
  class AllUsers < BaseResolver
    type [Types::UserType], null: false

    def resolve
      ::User.all
    end
  end
end
```

### Query
用意したModel、Type、Resolverを利用して、GraphiQLで下記のクエリを実行すると...
```graphql
query {
  allUsers {
    id
    name
    postedPhotos {
      name
    }
  }
}
```

### Response
クエリの結果はこのようになります。
```json
{
  "data": {
    "allUsers": [
      {
        "id": "1",
        "name": "テストユーザー1",
        "postedPhotos": [
          {
            "name": "カフェでの一枚"
          },
          {
            "name": "美味しい料理"
          },
          {
            "name": "チームミーティング"
          }
        ]
      },
      {
        "id": "2",
        "name": "テストユーザー2",
        "postedPhotos": [
          {
            "name": "山の頂上"
          },
          {
            "name": "お気に入りの場所"
          },
          // 以下略
        ]
      }
    ]
  }
}
```

### 発行されるSQL
Railsのログを確認すると、下記のようなSQLが発行されており、N+1問題が発生していることがわかります。

```sql
User Load (0.9ms)  SELECT `users`.* FROM `users`
Photo Load (0.3ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 1
Photo Load (0.2ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 2
Photo Load (0.1ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 3
Photo Load (0.1ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 4
Photo Load (0.1ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` = 5
```

## GraphQL::Batchによる解決策

graphql-batch gem の Loaders::AssociationLoaderを利用して、N+1問題を解決します。

### GraphQL::Batchの導入
Gemfileに下記を追加して、`bundle install` を実行します。
```ruby:Gemfile
gem 'graphql-batch'
```

schemaの設定を下記のように修正します。
```diff ruby:app/graphql/****_schema.rb
class ****Schema < GraphQL::Schema
  mutation(Types::MutationType)
  query(Types::QueryType)

+ use GraphQL::Batch

  # 以下略
end
```

### AssociationLoader
GraphQL::Batchの[examplesディレクトリ](https://github.com/Shopify/graphql-batch/tree/main/examples)に、ActiveRecord用のLoaderの例が用意されています。

そのうちの一つであるAssociationLoaderを利用すると、ActiveRecordのアソシエーションを効率的にまとめて読み込むことができます。

今回は、[examplesディレクトリ](https://github.com/Shopify/graphql-batch/tree/main/examples)にある association_loader.rb の内容そのままで下記のLoaderを作成し、UserTypeのposted_photosフィールドで利用してみます。

```ruby:app/graphql/loaders/association_loader.rb
module Loaders
  class AssociationLoader < GraphQL::Batch::Loader
    def self.validate(model, association_name)
      new(model, association_name)
      nil
    end

    def initialize(model, association_name)
      super()
      @model = model
      @association_name = association_name
      validate
    end

    def load(record)
      raise TypeError, "#{@model} loader can't load association for #{record.class}" unless record.is_a?(@model)
      return Promise.resolve(read_association(record)) if association_loaded?(record)

      super
    end

    # We want to load the associations on all records, even if they have the same id
    def cache_key(record)
      record.object_id
    end

    def perform(records)
      preload_association(records)
      records.each {|record| fulfill(record, read_association(record)) }
    end

    private

      def validate
        unless @model.reflect_on_association(@association_name)
          raise ArgumentError, "No association #{@association_name} on #{@model}"
        end
      end

      def preload_association(records)
        ::ActiveRecord::Associations::Preloader.new(records: records, associations: @association_name).call
      end

      def read_association(record)
        record.public_send(@association_name)
      end

      def association_loaded?(record)
        record.association(@association_name).loaded?
      end
  end
end
```

### Type
UserTypeのposted_photosフィールドを下記のように修正します。

AssociationLoaderは、`AssociationLoader.for(model, association_name).load(object)` という形式で、指定されたモデルの指定された関連をロードできます。

```diff ruby:user_type.rb
module Types
  class UserType < Types::BaseObject
    field :id, ID, null: false
    field :name, String
    field :posted_photos, [Types::PhotoType], null: false

    def posted_photos
+     Loaders::AssociationLoader.for(User, :photos).load(object)
-     object.photos
    end
  end
end
```

### 発行されるSQL
UserTypeの変更後に下記クエリを再度GraphiQLで実行してみます。

```graphql
query {
  allUsers {
    id
    name
    postedPhotos {
      name
    }
  }
}
```

クエリ実行後にRailsのログを確認すると、下記のようなSQLが発行されており、N+1問題が解決されていることがわかります🎊

```sql
User Load (0.2ms)  SELECT `users`.* FROM `users`
Photo Load (2.6ms)  SELECT `photos`.* FROM `photos` WHERE `photos`.`user_id` IN (1, 2, 3, 4, 5)
```

N+1問題が解決されのでめでたしめでたし...という感じなのですが、ここで思ったのです。

AssociationLoaderの中身をコピペしただけで、中身をよく理解しないまま使ってしまってるなと...

ということで、仕組みを少しでも理解するため、無謀にもAssociationLoaderのコードリーディングに挑戦することにしました😉

以下はその足掻いた記録です📝

# コードリーディング

## GraphQL::Batch::Loader.for
`Loaders::AssociationLoader.for(User, :photos)` を実行した場合の処理の流れを追ってみます。

上記を実行すると、AssociationLoader が継承している GraphQL::Batch::Loader 内に定義されている 下記の`for` メソッドが呼び出されます。

https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/loader.rb#L3-L14

Ruby 2.7 以降であれば、引数転送構文を利用するdef self.for(...) の部分が実行されます。

それでは、`for` メソッドの中身を見ていきます。

### GraphQL::Batch::Loader.loader_key_for
`current_executor.loader(loader_key_for(...)) { new(...) }`の`loader_key_for(...)`の部分から見ていきます。

https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/loader.rb#L16-L18
* `for`メソッドで渡された引数 User と :photos が、group_args として [User, :photos] にまとめられ、キーワード引数は空のハッシュ {} となります。
* また、self はこの場合 Loaders::AssociationLoader になります。
* 結果として、ローダーキーは
  [Loaders::AssociationLoader, {}, [User, :photos]]
  となり、このキーを使って同じ引数での呼び出しがあれば同じローダーを再利用する仕組みになっています。

### GraphQL::Batch::Loader.current_executor
`current_executor.loader(loader_key_for(...)) { new(...) }`の`current_executor`の部分を見ていきいます。
https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/loader.rb#L28-L43
`current_executor` は `GraphQL::Batch::Executor.current` を呼び出して、executor変数に結果を代入して返しています。

`GraphQL::Batch::Executor.current` の中身はどうなっているのでしょうか？

### GraphQL::Batch::Executor.current
https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/executor.rb#L1-L9

このコードを見てあれ？と思いました。

これまで読んできたコードで`Thread.current[THREAD_KEY]` に何か格納しているような処理を見たことがなかったからです。

`Thread.current[THREAD_KEY]`が空で、`GraphQL::Batch::Executor.current` がnilだと、`GraphQL::Batch::Loader.current_executor` がGraphQL::Batch::NoExecutorErrorをraisesするはずですが、`Loaders::AssociationLoader.for(User, :photos)` を実行した際にそのようなエラーは発生していませんでした。

ということは、`Thread.current[THREAD_KEY]` は何か格納されているはずです。

`Thread.current[THREAD_KEY]`の中身を確認してみると、下記の通り、`GraphQL::Batch::Executor` のインスタンスが格納されていました🔬

```
#<GraphQL::Batch::Executor:0x0000ffff956eebd8 
  @loaders={}, 
  @loading=false, 
  @nesting_level=1
>
```
ここでまた疑問が浮かんできます🤔

`Thread.current[THREAD_KEY]` に `GraphQL::Batch::Executor` のインスタンスを格納する処理はどこで行われているのでしょうか？

### GraphQL::Batch::Executor.start_batch
`current`メソッドの近くを嗅ぎ回っていると、それっぽいコードを見つけました。

https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/executor.rb#L15-L18

この部分では、`Thread.current[THREAD_KEY]` に既存の Executor がなければ、新しい Executor インスタンスを作成し、それを `Thread.current[THREAD_KEY]` に格納しています。

それでは、`start_batch`メソッドはどこで呼ばれているのでしょうか？

### GraphQL::Batch.batch
ここで呼ばれていました。

https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch.rb#L4-L16

`batch`メソッドがどこで呼ばれているか探しましたが、見つかりません。

どうやら、app/graphql/****_schema.rb に `use GraphQL::Batch` を書くと、下記のように`GraphQL::Batch.batch`のブロック内でLoaderが実行されるようになるようです。

```ruby
GraphQL::Batch.batch do
  Loaders::AssociationLoader.for(User, :photos)
end
```
コードを追ってみると、
スキーマに`use GraphQL::Batch`を書く → `GraphQL::Schema.use`が実行される → `GraphQL::Batch.use`が実行される → GraphQLのクエリ実行時に内部で自動的に `GraphQL::Batch.batch` が呼ばれるようになる
という流れっぽかったのですが、`GraphQL::Batch.use`の部分が難しかったので一旦スルーします😇

ここまで読んできてやっと`GraphQL::Batch::Loader.current_executor` で何が行われているのか、なんとなく理解できました。

`GraphQL::Batch::Loader.for`の中身`current_executor.loader(loader_key_for(...)) { new(...) }`でまだ確認していないのは`loader`メソッドです。

### GraphQL::Batch::Executor#loader
https://github.com/Shopify/graphql-batch/blob/main/lib/graphql/batch/executor.rb#L41-L46

* `@loaders[key] ||= ...` の部分
まず、この `loader`メソッドは、与えられた key に対して既に作成済みのローダーがあるかどうかを確認します。
もし既存のローダーがあればそのまま返し、なければ`yield`以降の処理を実行します。
* `yield` の部分
ブロックが渡されている場合、そのブロックを実行します。
`loader`メソッドに渡されているブロック内の処理は`new(...)`となっているため、今回の例では`Loaders::AssociationLoader.new(User, :photos).new` が実行され、新しいローダーのインスタンスが生成されます。
* `yield.tap do |loader| ... end` の部分
Rubyの`tap`メソッドは、オブジェクト自身を返す前にブロックを実行し、何らかの処理を行いたいときに使います。
今回の場合、`yield` によって生成されたローダーインスタンスを受け取り、そのインスタンスに対して下記の処理を行い、処理後のインスタンスを返します。
  * ローダーインスタンスの`executor`に`self`(現在のExecutorインスタンス)を設定
  * ローダーインスタンスの`loader_key`に`key`（今回の例では`[Loaders::AssociationLoader, {}, [User, :photos]]`）を設定
